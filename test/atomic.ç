#inclou "test.cç"
#inclou <est_atòmic.cç>

#si 0
#inclou <pthread.h>
#acaba_si

estàtic enter incrementa(_Atòmic enter *p) {
  enter valor_antic = *p;
  enter valor_nou;
  fes {
    valor_nou = valor_antic + 1;
  } mentre (!comparar_i_intercanviar_atòmic_fluix(p, &valor_antic, valor_nou));
  retorna valor_nou;
}

estàtic enter afegeix_1(buit *arg) {
  _Atòmic enter *x = arg;
  per (enter i = 0; i < 1000*1000; i++)
    incrementa(x);
  retorna 0;
}

estàtic enter afegeix_2(buit *arg) {
  _Atòmic enter *x = arg;
  per (enter i = 0; i < 1000*1000; i++)
    (*x)++;
  retorna 0;
}

estàtic enter afegeix_3(buit *arg) {
  _Atòmic enter *x = arg;
  per (enter i = 0; i < 1000*1000; i++)
    *x += 5;
  retorna 0;
}

#si 0
estàtic enter add_millions(buit) {
  _Atòmic enter x = 0;

  pthread_t thr1;
  pthread_t thr2;
  pthread_t thr3;

  pthread_create(&thr1, NULL, afegeix_1, &x);
  pthread_create(&thr2, NULL, afegeix_2, &x);
  pthread_create(&thr3, NULL, afegeix_3, &x);

  per (enter i = 0; i < 1000*1000; i++)
    x--;

  pthread_join(thr1, NULL);
  pthread_join(thr2, NULL);
  pthread_join(thr3, NULL);
  retorna x;
}
#acaba_si

enter principal() {
#si 0
  AFIRMA(6*1000*1000, add_millions());
#acaba_si

  AFIRMA(3, ({ enter x=3; intercanviar_atòmic(&x, 5); }));
  AFIRMA(5, ({ enter x=3; intercanviar_atòmic(&x, 5); x; }));

  imprimeix("OK\n");
  retorna 0;
}
